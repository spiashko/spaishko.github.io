<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>My DRY implementation of GET rest-point | Siarhei Piashko</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Introduction For long time I was interested in finding the most simple, small, flexible and the same time efficient implementation of GET rest-points. So in this article I will try to share my findings and hope you discover something interesting for you. And to make it easier to explain and understand let&rsquo;s design and implement simple application with a couple of entities.
Design application Assume we need to develop simple application to serve data about people and theirs cats.">
    <meta name="generator" content="Hugo 0.92.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    
      

    

    
    
    <meta property="og:title" content="My DRY implementation of GET rest-point" />
<meta property="og:description" content="Introduction For long time I was interested in finding the most simple, small, flexible and the same time efficient implementation of GET rest-points. So in this article I will try to share my findings and hope you discover something interesting for you. And to make it easier to explain and understand let&rsquo;s design and implement simple application with a couple of entities.
Design application Assume we need to develop simple application to serve data about people and theirs cats." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://spiashko.github.io/posts/rest-persistence/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-05T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-01-05T00:00:00+00:00" />

<meta itemprop="name" content="My DRY implementation of GET rest-point">
<meta itemprop="description" content="Introduction For long time I was interested in finding the most simple, small, flexible and the same time efficient implementation of GET rest-points. So in this article I will try to share my findings and hope you discover something interesting for you. And to make it easier to explain and understand let&rsquo;s design and implement simple application with a couple of entities.
Design application Assume we need to develop simple application to serve data about people and theirs cats."><meta itemprop="datePublished" content="2022-01-05T00:00:00+00:00" />
<meta itemprop="dateModified" content="2022-01-05T00:00:00+00:00" />
<meta itemprop="wordCount" content="691">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="My DRY implementation of GET rest-point"/>
<meta name="twitter:description" content="Introduction For long time I was interested in finding the most simple, small, flexible and the same time efficient implementation of GET rest-points. So in this article I will try to share my findings and hope you discover something interesting for you. And to make it easier to explain and understand let&rsquo;s design and implement simple application with a couple of entities.
Design application Assume we need to develop simple application to serve data about people and theirs cats."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Siarhei Piashko
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=https://spiashko.github.io/posts/rest-persistence/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=https://spiashko.github.io/posts/rest-persistence/&amp;text=My%20DRY%20implementation%20of%20GET%20rest-point" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://spiashko.github.io/posts/rest-persistence/&amp;title=My%20DRY%20implementation%20of%20GET%20rest-point" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>


      <h1 class="f1 athelas mt3 mb1">My DRY implementation of GET rest-point</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2022-01-05T00:00:00Z">January 5, 2022</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h3 id="introduction">Introduction</h3>
<p>For long time I was interested in finding the most simple, small, flexible and the same time efficient implementation of
GET rest-points. So in this article I will try to share my findings and hope you discover something interesting for you.
And to make it easier to explain and understand let&rsquo;s design and implement simple application with a couple of entities.</p>
<h3 id="design-application">Design application</h3>
<p>Assume we need to develop simple application to serve data about <strong>people</strong> and theirs <strong>cats</strong>. And this application
should have next features:</p>
<table>
<thead>
<tr>
<th>Features</th>
<th>Request params</th>
</tr>
</thead>
<tbody>
<tr>
<td>filtering</td>
<td>filter</td>
</tr>
<tr>
<td>inclusion</td>
<td>include</td>
</tr>
</tbody>
</table>
<p><strong>note:</strong> by inclusion means to allow requester define scope of receiving data (like GraphQL or in REST
world <a href="https://jsonapi.org/">JSON:API</a>)</p>
<p>Considering requirements above our application should be able to handle such GET requests as below</p>
<pre tabindex="0"><code>https://api.example.com/examples?filter=&lt;some_condition&gt;&amp;include=&lt;some_fields&gt;
</code></pre><p>And let&rsquo;s briefly describe our entities:</p>
<p><img src="https://spiashko.github.io/static/rest-persistence.png" alt="ERD"></p>
<h3 id="filtering">Filtering</h3>
<p>There is lots of different approaches how to achieve this goal but my personal choice is <code>RSQL</code> with spring-data
<code>Specification</code> and in particular this spring boot starter <a href="https://github.com/perplexhub/rsql-jpa-specification">https://github.com/perplexhub/rsql-jpa-specification</a></p>
<p>In short library above allows converting string like <code>code=='demo';company.id&gt;100</code> into spring-data <code>Specification</code>
which later we be evaluated and as a result we will get only entities which has field <code>code</code> as <code>demo</code> and
theirs <code>company</code> relation has <code>id</code> more than <code>100</code></p>
<p>To make it even more convenient we can create custom annotation which will be used in next way:</p>
<pre tabindex="0"><code>    #http://localhost:8080/cats?filter=owner.name==bob;name==scooter
    #expression inside filter param mapped into rsqlSpec argument
    @GetMapping(&quot;/cats&quot;)
    public List&lt;Cat&gt; findAll(
            @RsqlSpec Specification&lt;Cat&gt; rsqlSpec
    ) {
        List&lt;Cat&gt; result = searchService.findAll(rsqlSpec);
        return result;
    }
</code></pre><h3 id="inclusion">Inclusion</h3>
<p>Here is the most interesting part at least for me:) So we want a user define a scope of receiving data, and also we
don&rsquo;t want to write a lot of code, ideally just one annotation as it is done in filtering part.</p>
<p>So first I looked at JSON:API implementations in Java to steal solution from there and the most ready for production was
project <a href="https://elide.io/">elide</a>, but I found that it has build in N+1 problem which is by design there and beside of
this it looks really not usual comparing to standard spring boot, you may find demo
app <a href="https://github.com/spiashko/elide-demo">here</a>, so I continued my research.</p>
<p>Obviously I started to look at GraphQL implementations trying to steal solution from them. While looking, I bumped
into <a href="https://persistence.blazebit.com/">blaze persistence</a>. I must say it is very nice lib which have solutions for
different data access problems. Actually thanks to this lib I found a solution for cursor pagination, but it is for
separate article. And even-though in the end this lib doesn&rsquo;t contain that magic annotation I found it worth to mention.
<a href="https://github.com/spiashko/blaze-persistence-graphql-demo">Here</a> is my demo project with Blaze Persistence GraphQL.</p>
<p>After some time I
found <a href="https://piotrminkowski.com/2020/07/31/an-advanced-guide-to-graphql-with-spring-boot/">this article about GraphQL</a>
from Piotr Minkowski and the most interesting part is this code snippet:</p>
<pre tabindex="0"><code>private Specification&lt;Department&gt; fetchEmployees() {
   return (Specification&lt;Department&gt;) (root, query, builder) -&gt; {
      Fetch&lt;Department, Employee&gt; f = root.fetch(&quot;employees&quot;, JoinType.LEFT);
      Join&lt;Department, Employee&gt; join = (Join&lt;Department, Employee&gt;) f;
      return join.getOn();
   };
}
</code></pre><p>So the key point is the fact that we can make fetch join right inside Specification. And knowing that fact writing
custom solution is just piece of cake and here it is:</p>
<pre tabindex="0"><code>public class RfetchSupport {

    public Specification&lt;Object&gt; toSpecification(List&lt;String&gt; includedPaths) {
        Specification&lt;Object&gt; rfetchSpec = includedPaths.stream()
                .map(this::buildSpec)
                .reduce(Specification.where(null),
                        Specification::and);
        return rfetchSpec;
    }

    private Specification&lt;Object&gt; buildSpec(String attributePath) {
        return (root, query, builder) -&gt; {
            PropertyPath path = PropertyPath.from(attributePath, root.getJavaType());
            FetchParent&lt;Object, Object&gt; f = traversePath(root, path);
            Join&lt;Object, Object&gt; join = (Join&lt;Object, Object&gt;) f;

            query.distinct(true);

            return join.getOn();
        };
    }

    private FetchParent&lt;Object, Object&gt; traversePath(FetchParent&lt;?, ?&gt; root, PropertyPath path) {
        FetchParent&lt;Object, Object&gt; result = root.fetch(path.getSegment(), JoinType.LEFT);
        return path.hasNext() ? traversePath(result, Objects.requireNonNull(path.next())) : result;
    }

}
</code></pre><p>And obviously we can create custom annotation to make our controller looks like below</p>
<pre tabindex="0"><code>    #http://localhost:8080/cats?include=father;mother
    @GetMapping(&quot;/cats&quot;)
    public List&lt;Cat&gt; findAll(
            @RfetchSpec Specification&lt;Cat&gt; rFetchSpec
    ) {
        List&lt;Cat&gt; result = searchService.findAll(rFetchSpec);
        return result;
    }
</code></pre><h3 id="collect-all-together">Collect all together</h3>
<p>Long story short now we can define our GET controller in super short way and give client as much flexibility as possible.</p>
<pre tabindex="0"><code>    #http://localhost:8080//cats?filter=owner.name==bob&amp;include=father;mother
    @GetMapping(&quot;/cats&quot;)
    public List&lt;Cat&gt; findAll(
            @RfetchSpec Specification&lt;Cat&gt; rFetchSpec,
            @RsqlSpec Specification&lt;Cat&gt; rSqlSpec
    ) {
        val spec = Stream.of(rFetchSpec, rSqlSpec)
                .reduce(Specification.where(null),
                        Specification::and);
        List&lt;Cat&gt; result = searchService.findAll(spec);
        return result;
    }

</code></pre><p>You may find all code in my <a href="https://github.com/spiashko/rest-persistence">github</a></p>
<h3 id="todo">TODO</h3>
<p>Create annotation for cursor pagination</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://spiashko.github.io/" >
    &copy;  Siarhei Piashko 2022 
  </a>
    <div>














</div>
  </div>
</footer>

  </body>
</html>
